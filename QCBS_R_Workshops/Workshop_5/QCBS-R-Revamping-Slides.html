<!DOCTYPE html>
<html>
  <head>
    <title>Workshop 5: Programming in R</title>
    <meta charset="utf-8">
    <meta name="author" content="Québec Centre for Biodiversity Science" />
    <link href="assets/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="assets/font-awesome-4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="assets/academicons-1.8.1/css/academicons.min.css">
    <link rel="stylesheet" href="qcbsR.css" type="text/css" />
    <link rel="stylesheet" href="qcbsR-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Workshop 5: Programming in R
## QCBS R Workshop Series
### Québec Centre for Biodiversity Science

---




## Outline

- Control Flow
- Writing functions in R
- Speeding up your code
- Useful R packages for biologists

---
class: inverse, center, middle

# Control flow

---

## Control flow

Program flow control can be simply defined as the order in which a program is executed

### Why is it advantageous to have structured programs?

- It decreases the complexity and time of the task at hand
- This logical structure also means that the code has increased clarity
- It also means that many programmers can work on one program.

**This means increased productivity**

---
## Control flow

Flowcharts can be used to plan programs and represent their structure

&lt;br&gt;

![](images/flowchart1.png)



---
## Representing structure

The two basic building blocks of codes are the following:

.column[

#### Selection

Program’s execution determined by statements

```r
if
if else
```

]

.column[

#### Iteration

Repetition, where the statement will **loop** until a criteria is met

```r
for
while
repeat
```
]

---
## Decision making
Decision making is an important part of programming

.column[

#### If statement

```R
if(condition) {
  expression
}
```
.center[
![:scale 40%](images/if.png)
]
]

.column[

#### If...else statement

```r
if(condition) {
  expression 1
} else {
  expression 2
}
```
.center[
![:scale 25%](images/ifelse.png)
]
]


---
## What if you want to test more than one thing?

- `if` and `if`/`else` test a single condition
- Use `ifelse` function to:
    - test a vector of conditions
    - apply a function only under certain conditions

```r
a &lt;- 1:10
ifelse(a &gt; 5, "yes", "no")

a &lt;- (-4):5
sqrt(ifelse(a &gt;= 0, a, NA))
```

---
## Nested `if...else` statement

```r
if (test_expression1) {
statement1
} else if (test_expression2) {
statement2
} else if (test_expression3) {
statement3
} else {
statement4
}
```
.center[
![:scale 63%](images/nested_ifelse.png)]

---
## Exercise 1

```R
Paws &lt;- "cat"
Scruffy &lt;- "dog"
Sassy &lt;- "cat"
animals &lt;- c(Paws, Scruffy, Sassy)
```

1. Use an `if` statement to print “meow” if `Paws` is a “cat”.
2. Use an `if`/`else` statement to print “woof” if you supply an object that is a “dog” and “meow” if it is not. Try it out with `Paws` and `Scruffy`.
3. Use the `ifelse` function to display “woof” for `animals` that are dogs and “meow” for `animals` that are cats.

---
## Beware of R’s expression parsing!

Use curly brackets `{}` so that R knows to expect more input

Try:
```R
if (2+2) == 4 print("Arithmetic works.")
else print("Houston, we have a problem.")
```

.alert[This doesn't work because R evaluates the first line and doesn't know that you are going to use an `else` statement]

Instead use:

```R
if (2+2) == 4 {
  print("Arithmetic works.")
} else {
  print("Houston, we have a problem.")
}
```
---
## Remember the logical operators



| command  | meaning |
| ------------- | ------------- |
| `==`  | equal to  |
| `!=`  | not x  |
| `&lt;`   | less than  |
| `&lt;=`  | less than or equal to  |
| `&gt;`   | greater than  |
| `&gt;=`  | greater than or equal to  |
| `x&amp;y` | x AND y |
| `x`&amp;#124;`y`  | x OR y  |
| `isTRUE(x)`  | test if X is true |


---
## Iteration

Every time some operations have to be repeated, a loop may come in handy

Loops are good for:

- doing something for every element of an object
- doing something until the processed data runs out
- doing something for every file in a folder
- doing something that can fail, until it succeeds
- iterating a calculation until it converges

---
## `for` loop

```R
for(val in sequence) {
  statement
  }
```

.center[
![:scale 60%](images/forloop.png)
]


---  
## `for` loop

The letter `i` can be replaced with any variable name and the sequence can be almost anything, even a list of vectors

```r
for (a in c("Hello", "R", "Programmers")) {
  print(a)
}

for (z in 1:30) {
  a &lt;- rnorm(n = 1, mean = 5, sd = 2)
  print(a)
}

elements &lt;- list(1:3, 4:10)
for (element in elements) {
  print(element)
}
```

---
## `for` loop

In the example below, R would evaluate the expression 5 times:

```R
for(i in 1:5) {
  expression
}
```

In this secod example, in the first iteration, R would replace every instance of `i` with `2`. In the second iteration `i` would be replaced with `4`, then 6, and so on. 

```R
for(m in 1:10) {
  print(m*2)
}
```

---
## `for` loop

```r
x &lt;- c(2,5,3,9,6)
count &lt;- 0

for (val in x) {
  if(val %% 2 == 0) {
    count = count+1 
  }
}
print(count)
```

.center[
![:scale 51%](images/forexample.png)
]




---
## `for` loop

For loops are often used to loop over a dataset. We will use loops to perform functions on the `CO2` dataset which is built in R.

```R
data(CO2) # This loads the built in dataset

for (i in 1:length(CO2[,1])) { # for each row in the CO2 dataset
  print(CO2$conc[i]) # print the CO2 concentration
}

for (i in 1:length(CO2[,1])) { # for each row in the CO2 dataset
  if(CO2$Type[i] == "Quebec") { # if the type is "Quebec"
    print(CO2$conc[i]) # print the CO2 concentration 
    }
}
```

---
## `for` loop

.alert[Tip 1] to loop over the number of rows of a data frame, we can use the function `nrow()`

```r
for (i in 1:nrow(CO2)) { # for each row in the CO2 dataset
  print(CO2$conc[i]) # print the CO2 concentration
}
```

.alert[Tip 2] if we want to perform operations on the elements of one column, we can directly iterate over it

```r
for (i in 1:CO2$conc) { # for every element of the column conc of the CO2 dataset
  print(i) # print the ith element
}
```

---
## `for` loop

The expression part of the loop can be almost anything and is usually a compound statement containing many commands.

```r
for (i in 4:5) { # for i in 4 to 5
  print(colnames(CO2)[i])  
  print(mean(CO2[,i])) # print the mean of that column from the CO2 dataset
}
```

---
## Nested `for` loop

In some cases, you may want to use nested loops to accomplish a task. When using nested loops, it is important to use different variables as counters for each of your loops. Here we used *i* and *n* :

```r
for (i in 1:5) {
  for (n in 1:5) {
    print (i*n)
  }
}
```

---
## Exercise 2

You have realized that your tool for measuring uptake was not calibrated properly at Quebec sites and all measurements are 2 units higher than they should be. 

1. Use a loop to correct these measurements for all Quebec sites.

2. Use a vectorisation-based method to calculate the mean CO2-uptake in both areas.

---
## Answer to exercise 2

```r
for (i in 1:length(CO2[,1])) {
  if(CO2$Type[i] == "Quebec") {
    CO2$uptake[i] &lt;- CO2$uptake[i] - 2
  }
}
tapply(CO2$uptake, CO2$Type, mean)
```
&lt;!-- remove tapply from the exercice or explain it before --&gt;

---
## Modifying iterations

Normally, loops iterate over and over until they finish

To change this behavior break out of the loop entirely using `break` or stop executing the current iterationand jump to the next using `next`

---
## Modifying iterations: `break`

```r
for(val in x) {
  if(condition) { break }
  statement
}
```

![](images/break.png)

---
## Modifying iterations: `next`

```r
for(val in x) {
  if(condition) { next }
  statement
}
```

![](images/next.png)

---
## Modifying iterations: example

Print the CO2 concentrations for "chilled" treatments and keep count of how many replications there were.

```r
count &lt;- 0 # count is being set at zero so that we can edit this object in the loop to keep track of how many iterations were performed
 
for (i in 1:nrow(CO2)) {
  if (CO2$Treatment[i] == "nonchilled") next 
  # Skip to next iteration if treatment is nonchilled
  count &lt;- count + 1
  print(CO2$conc[i])
}
print(count) # The count and print command were performed 42 times.
 
```

---
## Modifying iterations: example

This could be equivalently written using a repeat loop: 

```r
count &lt;- 0
i &lt;- 0
repeat {
      i &lt;- i + 1
      if (CO2$Treatment[i] == "nonchilled") next  # skip this loop
      count &lt;- count + 1
      print(CO2$conc[i])
      if (i == nrow(CO2)) break     # stop looping
    }  
 
print(count) 
```

---
## Modifying iterations: example

This could also be written using a while loop: 

```r 
i &lt;- 0
count &lt;- 0
while (i &lt; nrow(CO2))
{
  i &lt;- i + 1
  if (CO2$Treatment[i] == "nonchilled") next  # skip this loop
  count &lt;- count + 1
  print(CO2$conc[i])
}
print(count) 
```

---
## Exercice 3

You have realized that your tool for measuring concentration didn't work properly. At Mississippi sites, concentrations less than 300 were measured correctly but concentrations &gt;= 300 were overestimated by 20 units. 

Use a loop to correct these measurements for all Mississippi sites.
&lt;br&gt;

Make sure you reload the data so that we are working with the raw data for the rest of the exercise:

```r
data(CO2)
```

---
## Answer to exercice 3

```r
for (i in 1:nrow(CO2)) {
  if(CO2$Type[i] == "Mississippi") {
    if(CO2$conc[i] &lt; 300) next 
    CO2$conc[i] &lt;- CO2$conc[i] - 20 
  }
}
``` 
Note : We could also have written it that way, which is more concise and clear

```r
for (i in 1:nrow(CO2)) {
  if(CO2$Type[i] == "Mississippi" &amp;&amp; CO2$conc[i] &gt;= 300) {
    CO2$conc[i] &lt;- CO2$conc[i] - 20 
  }
}
```

---
## Create a plot using `for` loop and `if` 

Here we want to plot uptake values vs concentration, but we want to plot each point differently according to its type (Quebec or Mississippi) and treatment (“chilled” or “nonchilled”).


```r
plot(x = CO2$conc, y = CO2$uptake, type = "n", cex.lab=1.4, 
     xlab = "CO2 concentration", ylab = "CO2 uptake") 
# Type "n" tells R to not actually plot the points.
 
for (i in 1:length(CO2[,1])) {
  if (CO2$Type[i] == "Quebec" &amp; CO2$Treatment[i] == "nonchilled") {
    points(CO2$conc[i], CO2$uptake[i], col = "red")
  }
  if (CO2$Type[i] == "Quebec" &amp; CO2$Treatment[i] == "chilled") {
    points(CO2$conc[i], CO2$uptake[i], col = "blue")
  }
  if (CO2$Type[i] == "Mississippi" &amp; CO2$Treatment[i] == "nonchilled") {
    points(CO2$conc[i], CO2$uptake[i], col = "orange")
  }
  if (CO2$Type[i] == "Mississippi" &amp; CO2$Treatment[i] == "chilled") {
    points(CO2$conc[i], CO2$uptake[i], col = "green")
  }
}
```
 
 
---
## Create a plot using `for` loop and `if` 

&lt;img src="QCBS-R-Revamping-Slides_files/figure-html/unnamed-chunk-2-1.png" width="576" style="display: block; margin: auto;" /&gt;

---
## Exercice 4

Generate a plot of showing concentration versus uptake where each plant is shown using a different colour point. Bonus points for doing it with nested loops!

---
## Answer to exercice 4


```r
plot(x = CO2$conc, y = CO2$uptake, type = "n", cex.lab=1.4, 
     xlab = "CO2 concentration", ylab = "CO2 uptake") 
# Type "n" tells R to not actually plot the points.
 
plants &lt;- unique(CO2$Plant)
 
for (i in 1:nrow(CO2)){
  for (p in 1:length(plants)) { 
    if (CO2$Plant[i] == plants[p]) {
      points(CO2$conc[i], CO2$uptake[i], col = p)
    }
  }
}

```

---
## Answer to exercice 4

&lt;img src="QCBS-R-Revamping-Slides_files/figure-html/unnamed-chunk-4-1.png" width="768" style="display: block; margin: auto;" /&gt;

---
class: inverse, center, middle

# Writing functions

---
## Why write functions?

Much of the heavy lifting in R is done by functions. They are useful for:

- performing a task repeatedly, but configurably
- making your code more readable
- make your code easier to modify and maintain
- sharing code between different analyses
- sharing code with other people
- modifying R’s built-in functionality

---
## What is a function?

&lt;br&gt;
&lt;br&gt;
.center[
![](images/function.png)
]


---
## Syntax of a function

```r
function_name &lt;- function(argument1, argument2, ...) {
  expression...  # What we want the function to do
  return(value)  # Optional
}
```

---
## Arguments of a function

```r
function_name &lt;- function(argument1, argument2, ...) {
  expression...  
  return(value) 
}
```

Arguments are the entry values of your function. They are the information your function needs to be able to perform correctly. A function can have between 0 and an infinity of arguments.

---
## Example of arguments


```r
operations &lt;- function(number1, number2, number3) {
  result &lt;- (number1 + number2) * number3
  print(result)
}
 
operations(1, 2, 3)
#&gt; [1] 9
```

---
## Exercise 5

Using what you learned previously on flow control, create a function print_animal that takes an animal as argument and gives the following results :




```r
Scruffy &lt;- "dog"
Paws &lt;- "cat"
 
print_animal(Scruffy)
#&gt; [1] "woof"
 
print_animal(Paws)
#&gt; [1] "meow"
```


---
## Answer to exercise 5

```r
print_animal &lt;- function(animal) {
  if (animal == "dog") {
    print("woof")
  } else if (animal == "cat") {
    print("meow")
  }
}
```

---
## Default values in a function

Arguments can also be optional and be provided with a default value. This is useful when using a function often with the same settings as you can omit always repeating the same argument but it still provides the flexibility to change it if needed.


```r
operations &lt;- function(number1, number2, number3 = 3) {
  result &lt;- (number1 + number2) * number3
  print(result)
}
 
operations(1, 2, 3) # is equivalent to
#&gt; [1] 9
operations(1, 2)
#&gt; [1] 9
operations(1, 2, 2) # we can still change the value of number3 if needed
#&gt; [1] 6
```

---
## Argument `...`

The special argument `...` allows you to pass on arguments to another function used inside your function.

Here we use `...` to pass on arguments to `plot()` and `points()`


```r
plot.CO2 &lt;- function(CO2, ...) {
  plot(x=CO2$conc, y=CO2$uptake, type="n", ...) 
 
  for (i in 1:length(CO2[,1])){
     if (CO2$Type[i] == "Quebec") {
       points(CO2$conc[i], CO2$uptake[i], col="red", type="p", ...) 
     } else if (CO2$Type[i] == "Mississippi") {
       points(CO2$conc[i], CO2$uptake[i], col="blue", type="p", ...) 
     }
  }
}
 
plot.CO2(CO2, cex.lab=1.4, xlab="CO2 concentration", ylab="CO2 uptake")
plot.CO2(CO2, cex.lab=1.4, xlab="CO2 concentration", ylab="CO2 uptake", pch=20)
```


---
## Argument `...`

The special argument `...` allows you to pass on arguments to another function used inside your function.

Here we use `...` to pass on arguments to `plot()` and `points()`

&lt;img src="QCBS-R-Revamping-Slides_files/figure-html/unnamed-chunk-10-1.png" width="768" style="display: block; margin: auto;" /&gt;

---
## Argument `...`

The special argument `...` allows you to input an indefinite number of arguments.


```r
sum2 &lt;- function(...){
  args &lt;- list(...)
  result &lt;- 0
  for (i in args)  {
    result &lt;- result + i
  }
  return (result)
}
 
sum2(2, 3)
#&gt; [1] 5
sum2(2, 4, 5, 7688, 1)
#&gt; [1] 7700
```

---
## Return values

The last expression evaluated in a `function` becomes the return value.


```r
myfun &lt;- function(x) {
  if (x &lt; 10) {
    0
  } else {
    10
  }
}

myfun(5)
#&gt; [1] 0
myfun(15)
#&gt; [1] 10
```

Functions can return only a single object. But this is not a limitation because you can return a list containing any number of objects.

---
## Return values

`function()` itself returns the last evaluated value even without including `return()` function.
It can be useful to include an explicit `return()` if the routine should end early, jump out of the function and return a value.

```r
myfun &lt;- function(x) {
  if (x&lt;0) return(x)
  
  complicated processing here
}

```

---
## Exercise 6

Using what you learned so far on functions and control flow, create a function `bigsum` that takes two arguments a and b and :

- returns 0 if the sum of a and b is strictly less than 50
- returns the sum of a and b otherwise

---
## Answer to exercise 6

```r
bigsum &lt;- function(a, b) {
  result &lt;- a + b
  if (result &lt; 50) {
    return(0)
  } else {
    return (result)
  }
}
```
or

```r
bigsum &lt;- function(a, b) {
  result &lt;- a + b
  if (result &lt; 50) {
  0
  } else {
  result
  }
}
```

---
## Accessibility of variables

It is essential to always keep in mind where your variables are and whether they are defined and accessible.

- Variables defined inside a function are not accessible outside
- Variables defined outside a function are accessible inside. But it is NEVER a good idea, as your function won't function if the outside variable is erased.

```r
rm(list=ls()) # first let's remove everything to avoid any confusion
 
var1 &lt;- 3     # var1 is defined outside our function
vartest &lt;- function() {
  a &lt;- 4      # a is defined inside
  print(a)    # print a
  print(var1) # print var1
}
a             # print a. It doesn't work, a can be seen only inside the function
vartest()     # calling vartest() will print a and var1 
rm(var1)      # remove var1
vartest()     # calling the function again doesn't work anymore
```

---
## Accessibility of variables

Instead, use arguments!! Inside a function, arguments names will take over other variable names.


```r
var1 &lt;- 3     # var1 is defined outside our function
vartest &lt;- function(var1) {
  print(var1) # print var1
}
vartest(8)    # Inside our function var1 is now our argument and takes its value
#&gt; [1] 8
var1          # var1 still has the same value
#&gt; [1] 3
```

---

## Accessibility of variables

Be very careful when creating variables inside a conditionnal statement as the variable can never be created and cause errors

```r
a &lt;- 3
if (a &gt; 5) {
  b &lt;- 2
} 
a + b    # Error! b doesn't exist
```


Usually it is a good practice to define variables outside the conditions and then modify their value to avoid any problem

```r
a &lt;- 3
b &lt;- 0
if (a &gt; 5) {
  b &lt;- 2
} 
a + b
```

---
class: inverse, center, middle

# Good programming practices

---
class: inverse, center, middle

# Speeding up your code

---
class: inverse, center, middle

# Other packages of interest

---
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="qcbsR-macros.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
